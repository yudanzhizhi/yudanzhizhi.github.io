[{"title":"Hello World","url":"/2024/06/02/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Python","url":"/2024/06/27/Python/","content":"基础字符串a = &quot;abcde&quot;&gt;&gt;&gt;a[::-1]&#x27;edcba&#x27;&gt;&gt;&gt; a[1:2]&#x27;b&#x27;&gt;&gt;&gt;a[0:2]&#x27;ab&#x27;\n\n\n\n输入&gt;&gt;&gt; input(&quot;请输入：&quot;)请输入：ahahah&#x27;ahahah&#x27;&gt;&gt;&gt;\n\n\n\n输出#!/usr/bin/python3 str=&#x27;123456789&#x27; print(str)                 # 输出字符串print(str[0:-1])           # 输出第一个到倒数第二个的所有字符print(str[0])              # 输出字符串第一个字符print(str[2:5])            # 输出从第三个开始到第六个的字符（不包含）print(str[2:])             # 输出从第三个开始后的所有字符print(str[1:5:2])          # 输出从第二个开始到第五个且每隔一个的字符（步长为2）print(str * 2)             # 输出字符串两次print(str + &#x27;你好&#x27;)         # 连接字符串 print(&#x27;------------------------------&#x27;) print(&#x27;hello\\nrunoob&#x27;)      # 使用反斜杠(\\)+n转义特殊字符print(r&#x27;hello\\nrunoob&#x27;)     # 在字符串前面添加一个 r，表示原始字符串，不会发生转义\n\n\n\n循环while（没有do…while）：\nwhile &lt;condition&gt;:    &lt;statements&gt;else:    &lt;additional_statements&gt;\n\nfor：\nfor &lt;variable&gt; in &lt;sequence&gt;:    &lt;statements&gt;else:    &lt;statements&gt;\n\nrange()函数：\nrange([start,] stop[, step])\n\n\n\n推导式列表[表达式 for 变量 in 列表] [out_exp_res for out_exp in input_list]或者 [表达式 for 变量 in 列表 if 条件][out_exp_res for out_exp in input_list if condition]example:&gt;&gt;&gt; names = [&#x27;Bob&#x27;,&#x27;Tom&#x27;,&#x27;alice&#x27;,&#x27;Jerry&#x27;,&#x27;Wendy&#x27;,&#x27;Smith&#x27;]&gt;&gt;&gt; new_names = [name.upper() for name in names if len(name)&gt;3]&gt;&gt;&gt; print(new_names)[&#x27;ALICE&#x27;, &#x27;JERRY&#x27;, &#x27;WENDY&#x27;, &#x27;SMITH&#x27;]\n\n\n\n\n\n进制转换在python中二进制用0b加相应数字来表示，8进制用0o加相应数字来表示，16进制用0x加相应数字来表示。即:    #其他进制转换二进制#&gt;&gt;&gt; bin(2) #十进制转换二进制#&#x27;0b10&#x27;&gt;&gt;&gt; bin(0o10) #八进制转换二进制#&#x27;0b1000&#x27;&gt;&gt;&gt; bin(0xf) #十六进制转换二进制#&#x27;0b1111&#x27;#其他进制转换为八进制#&gt;&gt;&gt; oct(0b101)&#x27;0o5&#x27;&gt;&gt;&gt; oct(0xf)&#x27;0o17&#x27;&gt;&gt;&gt; oct(0o123)&#x27;0o123&#x27;        #其他进制转换为十六进制#&gt;&gt;&gt; hex(0o10)&#x27;0x8&#x27;&gt;&gt;&gt; hex(3)&#x27;0x3&#x27;&gt;&gt;&gt; hex(0b111)&#x27;0x7&#x27;#其他进制转换为十进制#&gt;&gt;&gt; int(0o10)8&gt;&gt;&gt; int(0xf)15&gt;&gt;&gt; int(0b10)2\n\n无限大&gt;&gt;&gt; float(&#x27;inf&#x27;)  # 不可以转化位int，int(float(&#x27;inf&#x27;))会报错\n\n\n位运算\n\n\n符号\n方法\n描述\n\n\n\n&amp;\n与\n两个位都为1时，结果才为1\n\n\n|\n或\n两个位都为0时，结果才为0\n\n\n^\n异或\n两个位相同为0，相异为1\n\n\n~\n取反\n0变1，1变0\n\n\n&lt;&lt;\n左移\n各二进位全部左移若干位，高位丢弃，低位补0\n\n\n&gt;&gt;\n右移\n各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）\n\n\nint.bit_length()\n二进制数长度\n获得int的二进制表示的长度（不包含0b）\n\n\nint.bit_count()\n1的个数\n获得int的二进制表示中1的个数\n\n\n((x &gt;&gt; i) &amp; 1) == 0 意思是判断 x 的第 i 位是否为 0x |= (1 &lt;&lt; i) 意思是把 x 的第 i 位设置为 1 \n数据结构列表（list）：[]\n\n\n方法\n描述\n\n\n\nlist.append(x)\n把一个元素添加到列表的结尾，相当于a[len(a):] &#x3D; [x]\n\n\nlist.clear()\n移除列表中的所有项，等于del a[:]。\n\n\nlist.copy()\n返回列表的浅复制，等于a[:]。\n\n\nlist.count(x)\n返回 x 在列表中出现的次数。\n\n\nlist.extend(L)\n通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] &#x3D; L。\n\n\nlist.index(x)\n返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。\n\n\nlist.insert(i, x)\n在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。\n\n\nlist.pop([i])\n从列表的指定位置移除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被移除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）\n\n\nlist.remove(x)\n删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。\n\n\nlist.reverse()\n倒排列表中的元素。\n\n\nlist.sort(cmp&#x3D;None, key&#x3D;None, reverse&#x3D;False)\n对列表中的元素进行排序。  cmp – 可选参数, 如果指定了该参数会使用该参数的方法进行排序。 key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。 reverse – 排序规则，reverse &#x3D; True 降序， reverse &#x3D; False 升序（默认）。\n\n\n删除列表元素的四种方法\ndel listname[index]\nlistname.pop(index)\nlistname.remove(value)\nlistname.clear()\n\n&gt;&gt;&gt; a = [66.25, 333, 333, 1, 1234.5]&gt;&gt;&gt; print(a.count(333), a.count(66.25), a.count(&#x27;x&#x27;))2 1 0&gt;&gt;&gt; a.insert(2, -1)&gt;&gt;&gt; a.append(333)&gt;&gt;&gt; a[66.25, 333, -1, 333, 1, 1234.5, 333]&gt;&gt;&gt; a.index(333)1&gt;&gt;&gt; a.remove(333)&gt;&gt;&gt; a[66.25, -1, 333, 1, 1234.5, 333]&gt;&gt;&gt; a.reverse()&gt;&gt;&gt; a[333, 1234.5, 1, 333, -1, 66.25]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[-1, 1, 66.25, 333, 333, 1234.5]\n\n\n求和sum()用法：\nsum(iterable[, start])# iterable -- 可迭代对象，如：列表、元组、集合。# start -- 指定相加的参数，如果没有设置这个值，默认为0。\n\n实例：\n&gt;&gt;&gt; sum([0,1,2])  3  &gt;&gt;&gt; sum((2, 3, 4), 1)        # 元组计算总和后再加 110&gt;&gt;&gt; sum([0,1,2,3,4], 2)      # 列表计算总和后再加 212\n\n\n求幂pow()用法：\n# math模块的pow()import mathmath.pow(x, y)# 内置的pow()pow(x, y[, z])  # 函数是计算 x 的 y 次方，如果 z 存在，则再对结果进行取模，其结果等效于 pow(x, y) % z。# 注意：pow() 通过内置的方法直接调用，内置方法会把参数作为整型，而 math 模块则会把参数转换为 float。\n\n实例：\n&gt;&gt;&gt; import math&gt;&gt;&gt; print &quot;math.pow(100, 2) : &quot;, math.pow(100, 2)math.pow(100, 2) :  10000.0&gt;&gt;&gt; print &quot;pow(100, 2) : &quot;, pow(100, 2)pow(100, 2) :  10000&gt;&gt;&gt; print &quot;math.pow(100, -2) : &quot;, math.pow(100, -2)math.pow(100, -2) :  0.0001&gt;&gt;&gt; print &quot;math.pow(2, 4) : &quot;, math.pow(2, 4)math.pow(2, 4) :  16.0&gt;&gt;&gt; print &quot;math.pow(3, 0) : &quot;, math.pow(3, 0)math.pow(3, 0) :  1.0\n\n\n\n\n\n\n哈希表1. 重新放置石块给你一个下标从 0 开始的整数数组 nums ，表示一些石块的初始位置。再给你两个长度 相等 下标从 0 开始的整数数组 moveFrom 和 moveTo 。在 moveFrom.length 次操作内，你可以改变石块的位置。在第 i 次操作中，你将位置在 moveFrom[i] 的所有石块移到位置 moveTo[i] 。完成这些操作后，请你按升序返回所有 有 石块的位置。\n注意：\n\n如果一个位置至少有一个石块，我们称这个位置 有 石块。\n一个位置可能会有多个石块。\n\n示例 1：\n\n输入：nums &#x3D; [1,6,7,8], moveFrom &#x3D; [1,7,2], moveTo &#x3D; [2,9,5]输出：[5,6,8,9]解释：一开始，石块在位置 1,6,7,8 。第 i &#x3D; 0 步操作中，我们将位置 1 处的石块移到位置 2 处，位置 2,6,7,8 有石块。第 i &#x3D; 1 步操作中，我们将位置 7 处的石块移到位置 9 处，位置 2,6,8,9 有石块。第 i &#x3D; 2 步操作中，我们将位置 2 处的石块移到位置 5 处，位置 5,6,8,9 有石块。最后，至少有一个石块的位置为 [5,6,8,9] 。\n\n示例 2：\n\n输入：nums &#x3D; [1,1,3,3], moveFrom &#x3D; [1,3], moveTo &#x3D; [2,2]输出：[2]解释：一开始，石块在位置 [1,1,3,3] 。第 i &#x3D; 0 步操作中，我们将位置 1 处的石块移到位置 2 处，有石块的位置为 [2,2,3,3] 。第 i &#x3D; 1 步操作中，我们将位置 3 处的石块移到位置 2 处，有石块的位置为 [2,2,2,2] 。由于 2 是唯一有石块的位置，我们返回 [2] 。\n\n提示：\n\n1 &lt;= nums.length &lt;= 105\n1 &lt;= moveFrom.length &lt;= 105\nmoveFrom.length == moveTo.length\n1 &lt;= nums[i], moveFrom[i], moveTo[i] &lt;= 109\n测试数据保证在进行第 i 步操作时，moveFrom[i] 处至少有一个石块。\n\nclass Solution:    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -&gt; List[int]:        mp = &#123;&#125;        result = []        for i in nums:            mp[i] = True        for i in range(len(moveFrom)):            if moveFrom[i] == moveTo[i]:                continue            mp[moveTo[i]] = True            del mp[moveFrom[i]]        result = list(mp.keys())        result.sort()        return result\n\n\n集合set()set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。\n创建格式：\nparame = &#123;value01, value02, ...&#125;   # 支持推导式 或者set(value)例子：set1 = &#123;1, 2, 3, 4&#125;              # 直接使用大括号创建集合set2 = set([4, 5, 6, 7])         # 使用 set() 函数从列表创建集合&gt;&gt;&gt; x = set(&#x27;eleven&#x27;)&gt;&gt;&gt; y = set(&#x27;twelve&#x27;)&gt;&gt;&gt; x,y(&#123;&#x27;l&#x27;, &#x27;e&#x27;, &#x27;n&#x27;, &#x27;v&#x27;&#125;, &#123;&#x27;e&#x27;, &#x27;v&#x27;, &#x27;l&#x27;, &#x27;t&#x27;, &#x27;w&#x27;&#125;)&gt;&gt;&gt; x &amp; y  #交集&#123;&#x27;l&#x27;, &#x27;e&#x27;, &#x27;v&#x27;&#125;&gt;&gt;&gt; x | y  #并集&#123;&#x27;e&#x27;, &#x27;v&#x27;, &#x27;n&#x27;, &#x27;l&#x27;, &#x27;t&#x27;, &#x27;w&#x27;&#125;&gt;&gt;&gt; x - y  #差集&#123;&#x27;n&#x27;&#125;&gt;&gt;&gt; y -x   #差集&#123;&#x27;t&#x27;, &#x27;w&#x27;&#125;&gt;&gt;&gt; x ^ y  #补集&#123;&#x27;t&#x27;, &#x27;n&#x27;, &#x27;w&#x27;&#125;&gt;&gt;&gt; y ^ x  #补集&#123;&#x27;w&#x27;, &#x27;n&#x27;, &#x27;t&#x27;&#125;&gt;&gt;&gt; \n\n\n\n\n方法\n描述\n\n\n\nadd(x)\n为集合添加元素，如果元素已存在，则不进行任何操作\n\n\nclear()\n移除集合中的所有元素\n\n\ncopy()\n拷贝一个集合\n\n\ndifference()\n返回多个集合的差集\n\n\ndifference_update()\n移除集合中的元素，该元素在指定的集合也存在。\n\n\ndiscard(x)\n删除集合中指定的元素。如果元素不存在不会发生错误。\n\n\nintersection(another_set)\n返回集合的交集，不改变原集合\n\n\nintersection_update(another_set)\n返回集合的交集，更新原集合为交集。\n\n\nisdisjoint()\n判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。\n\n\nissubset()\n判断指定集合是否为该方法参数集合的子集。\n\n\nissuperset()\n判断该方法的参数集合是否为指定集合的子集\n\n\npop()\n随机移除元素。原理：对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除\n\n\nremove(x)\n移除指定元素，如果元素不存在会发生错误。\n\n\nsymmetric_difference()\n返回两个集合中不重复的元素集合。\n\n\nsymmetric_difference_update()\n移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。\n\n\nunion()\n返回两个集合的并集\n\n\nupdate(x)\n给集合添加元素，x可以是列表，元组，字典等，可以有多个，用逗号分开，如set.update([1, 3], [6, 2])\n\n\nlen(set)\n计算集合元素个数\n\n\n元组（tuple）：()\nzip()zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。\n注意： zip 方法在 Python 2 和 Python 3 中的不同：在 Python 3.x 中为了减少内存，zip() 返回的是一个对象。如需展示列表，需手动 list() 转换。\n语法：\nzip([iterable, ...])# iterable: 一个或多个迭代器\n\npython 2\n&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b)     # 打包为元组的列表[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; zip(a,c)              # 元素个数与最短的列表一致[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式[(1, 2, 3), (4, 5, 6)]\n\npython 3\n&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b)     # 返回一个对象&gt;&gt;&gt; zipped&lt;zip object at 0x103abc288&gt;&gt;&gt;&gt; list(zipped)  # list() 转换为列表[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; list(zip(a,c))              # 元素个数与最短的列表一致[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; a1, a2 = zip(*zip(a,b))          # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式&gt;&gt;&gt; list(a1)[1, 2, 3]&gt;&gt;&gt; list(a2)[4, 5, 6]&gt;&gt;&gt;\n\n字典（dictionary）：{}\n\n\n方法\n描述\n\n\n\ndict.get(key[, value])\n返回指定键的值，如果键不在字典中返回默认值 None或者设置的默认值。\n\n\n\n\n\n\n\n\n\n\n方法：dict.get(key[, value])描述：返回指定键的值，如果键不在字典中返回默认值 None或者设置的默认值。&gt;&gt;&gt; a = &#123;&#125;&gt;&gt;&gt; print(&#x27;URL: &#x27;, a.get(&#x27;url&#x27;))     # 返回 NoneURL:  None&gt;&gt;&gt; b = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 27&#125;&gt;&gt;&gt; print (&quot;Age : %s&quot; %  b.get(&#x27;Age&#x27;))Age : 27&gt;&gt;&gt; print (&quot;Sex : %s&quot; %  b.get(&#x27;Sex&#x27;))  Sex : None&gt;&gt;&gt; print (&#x27;Salary: %s&#x27; % b.get(&#x27;Salary&#x27;, 0.0))Salary: 0.0\n\n\n\ncollecttions计数器Counter()\n&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; cnt = Counter()   &gt;&gt;&gt; cnt[0]   0\n\n默认字典defaultdict()\ncollections.defaultdict(list)  # 构建一个默认value为list的字典\n\n\n给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n示例 1:输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]\n示例 2:输入: strs &#x3D; [“”]输出: [[“”]]\n示例 3:输入: strs &#x3D; [“a”]输出: [[“a”]]\n提示：1 &lt;&#x3D; strs.length &lt;&#x3D; 1040 &lt;&#x3D; strs[i].length &lt;&#x3D; 100strs[i] 仅包含小写字母\nclass Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        if len(strs) &lt;= 1:            return [strs]        mp = collections.defaultdict(list)        for c in strs:            mp[&#x27;&#x27;.join(sorted(c))].append(c)        return list(mp.values())\n\n生成器generator创建：与用表达式创建列表一样，只不过将[]换成()\n&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;\n\n方法文件操作open()函数f &#x3D; open(“路径”, “模式”, 编码)，成功后返回一个文件对象\n&#x2F;&#x2F; r—–读取模式（只读） w——写入模式（只写）a——附加模式  r+——读写模式（文件内容后追加）\n&#x2F;&#x2F;编码为可选项，encoding&#x3D;”UTF-8”\n&#x2F;&#x2F;r模式下若文件不存在则会报错，而w&#x2F;a模式会创建一个新的文件\n读文件read()方法f.read()，一次性读取文件内所有内容并以字符串形式进行返回\n&#x2F;&#x2F;程序会记录文件读取位置，因此再次调用read()返回的结果为空\nf.read(10) &#x2F;&#x2F;读取第1-10个字节的文件内容\nf.read(10) &#x2F;&#x2F;再次调用，读取第11-20个字节的文件内容\nreadline()方法f.readline()，根据换行符来判断（换行符也会被读取），只读一行文件内容\n&#x2F;&#x2F;通过返回值是否为空判断是否读到文件结尾\nline=f.readline()while line != &quot;&quot;:    print(line)    line= f.readline()\n\n\n\nreadlines()方法f.readlines()，读取文件全部内容，把每行作为列表元素返回\nlines&#x3D; f.readlines()\nfor line in lines:\n   print(line)\nclose()方法f.close()，关闭文件\nwith关键字with open(“url”) as f:\n   print(f.read())  &#x2F;&#x2F;文件操作\n&#x2F;&#x2F;完成所有操作后自动关闭文件\n写文件&#x2F;&#x2F;w模式打开文件进行写入时，若文件原本已经存在，会清空原有内容，a模式不会\n&#x2F;&#x2F;w和a都没有read()\nwrite()方法f.write(“Hello! “)\nf.write(“Yoooo”)\n\n\n&#x2F;&#x2F;不会默认换行\n爬虫HTTP请求和响应请求：请求行+请求头+请求体GET（一般都是用GET）——用于获得数据：进入一个网页时，浏览器发送GET请求，得到网页内容\nPOST——用于创建数据：提交账号注册表单时，浏览器发送POST请求，把用户名、密码等信息放到请求主体里给到服务器\n\n请求行：方法类型 资源路径 协议版本资源路径指明要访问服务器的哪个资源，如www.douban.com/movie/top250，第一个斜杠（/）表示资源路径的根，所以根后面的/movie/top250就是要访问的资源的路径\n有时候还可以给出查询参数，问号（？）后面的就是查询参数，可以传递给服务器额外的信息，不同信息之间用&amp;分隔\n\n请求头：会包含一些给服务器的信息Host指主机域名，主机域名结合请求行里的路径资源，可以得到一个完整的网址\nUser-Agent用来告知服务器客服端的相关信息\n\nAccept是在告诉浏览器客户端想要接受的响应数据是什么类型的，接受多种类型可以用逗号分隔\n\n请求体：里面可以放客户端传给服务器的其他任意数据，但是GET的请求体一般是空的响应：状态行+响应头+响应体\n状态行：协议版本 状态码 状态消息2开头表示成功，请求已完成处理；3开头表示重定向，需要进一步操作；4开头表示客户端错误，如请求里面有错误或请求的资源无效；5开头表示服务器错误，如出现问题或正在维护\n\n响应头：包含一些告知客户端的信息Date，生产日期和时间\nContent-Type，返回内容的类型及编码格式\n响应体：服务器想给客户端的数据内容响应体里面的信息是我们秀昂要的信息\n构建和发送HTTP请求——Requests库get()方法response &#x3D; requests.get(URL)\n&#x2F;&#x2F;网址实际的URL还包括协议名\nok属性response.ok，返回布尔值，True为成功\ntext属性response.text，以字符串储存响应内容\nheaders参数response &#x3D; requests.get(URL, headers&#x3D;***)\n数据类型为字典，里面的哥哥键值对对应了我们要传入的各个信息\n一个例子：可以帮我们把爬虫程序伪装成正常浏览器。当我们使用浏览器时，浏览器向服务器发送GET请求，并且请求头的User-Agent会自动带有浏览器类型及版本，还有电脑的操作系统等等，用代码发送请求不会带有这些信息，服务器可以通过这一点判断进来的请求是来自浏览器还是程序\n解析网页内容——Beautiful Soup库from bs4 impot BeautifulSoup\nimport requests\ncontent &#x3D; requests.get(URL).text\n构造函数soup &#x3D; BeautifulSoup(content, “html.parser”)，获得一个实例对象，解析成下图所示的树形结构\n\n各种方法soup.p，得到这个HTML里的第一个p元素。若p里面还有其他标签，会把它们一起返回\nsoup.img，第一个img元素\nfind()方法link &#x3D; title.find(“a”)\n返回第一个对象，此例中为返回title里的第一个a元素\nfind_All()方法soup.findAll()，能根据标签、属性等找出所有符合要求的元素\nall_prices &#x3D; soup.findAll(“p”, attrs&#x3D;{“class”: “price_color”})，atts为可选参数，是一个字典，键值对就对应你想找的属性和值\n返回一个可迭代对象，所以可以通过循环依次操作返回的各个对象\nstring属性for price in all_prices:\n   print(price.string)\n会把标签包围的文字返回给我们\n"},{"title":"nice_resource","url":"/2024/06/27/nice-resource/","content":"\nSorted by Juanry\n\n视频低端影视 有很多高清流媒体\n资源阿里巴巴矢量图标库\nIconPark\n谷歌字体（也有很多图标）\nFont Awesome\n中国色\nCode examples\nMaziva（视频素材）\nBensound（无版权音乐）\nPixabay（音视频图像都有）\nAdobe（音频）\nPexels（图片）\nStreetWill（图片）\nUnsplash（图片）\n字由（字体，下载客户端）\n字体天下\n猫啃网（免费可商用字体）\n51PPT模板\n第1PPT\nMicrosoft Azure（免费服务器）\nLibrary Genesis+（电子书，需魔法）：\n\nLink 1\nLink 2\nLink 3\n\nZ-Library（电子书，需魔法）：\n\nLink 1\nLink 2\nLink 3\n\nElementUI（前端组件库）\n站酷（各种素材）\n编译原理（第2版）答案（紫龙书）\nOJ力扣\n洛谷（新手友好）\n炼码\nVirtual Judge\nUESTC OJ（使用校园网访问）\nCodeforces（定期举办比赛）\nAtCoder（日本的OJ，定期举办比赛）\n杭电OJ\n北大OJ\nLibreOJ \nHydroOJ\nAcWing（主要还是卖课的）\n工具chatgptAMZ chat（chatgpt镜像）\nWeTab 新标签页（插件，有chatgpt镜像）\nPoe（chatgpt，需魔法）\n编辑器SVG编辑器\niLovePDF（PDF在线工具）\nOverleaf（在线 $LaTeX$ 编辑器）  \n在线LaTeX公式编辑器\n翻译器DeepL（翻译）\n超星翻译（pdf翻译）  &#x2F;&#x2F; 看外文论文挺好用\n找论文中国知网\n万方\nWeb of Science（外文）  \n其他可画（海报、PPT等）\n秀米（排版）\nPix Fix（免费图片降噪修复）\nclip-path生成器\n在线抠图\n压缩图片工具\n标小智LOGO神器（做图标的）\nregex101（匹配正则表达式）\n数学GeoGebra（数学等画图）\nOEIS（数列找规律，你发现一个数列丢进去，往往能找到它是个啥数列）\nGraph Editor（图论画图工具）\nWolfram|Alpha（啥都能算）\nLaTeXLaTeX 数学公式大全\n常用数学符号的 LaTeX 表示方法\n如何用 Markdown&amp;LaTeX 写一篇排版整齐的题解？（当然对于写博客有指导意义）\nDetexify LaTeX handwritten symbol recognition（$LaTeX$ 符号手写识别）\n一份其实很短的 LaTeX 入门文档 | 始终\n学习菜鸟教程\nLinux命令大全\n头歌\nW3school\nMDN\n哔哩哔哩\n代码随想录\n维基百科\nLearn X in Y Minutes: Scenic Programming Language Tours\nOI Wiki（算法竞赛）\nhzwer&#x2F;shareOI: 算法竞赛课件分享 \n博客团队美团技术团队\n个人白忠建老师的博客\n廖雪峰大神的博客\n阮一峰的网络日志\nMatrix67: The Aha Moments（Matrix67 的博客，内有很多有趣的内容，大部分与数学相关）\n社区腾讯云开发者社区\n阿里云开发者社区\n"},{"title":"课程网课","url":"/2024/06/27/%E8%AF%BE%E7%A8%8B%E7%BD%91%E8%AF%BE/","content":"计算机组成原理         \n计算机网络        \n编译原理：          \n\n知识点复习+一点题         \n面向试卷复习        \n求first集和follow集\n\n数字信号处理\n"},{"title":"2024C4选拔赛感想","url":"/2024/06/28/2024C4%E9%80%89%E6%8B%94%E8%B5%9B%E6%84%9F%E6%83%B3/","content":"做了一个多月的项目，完成度和前景也挺好的，结果只拿到一个省三。排名前面的大部分都是大模型，不得不说，现在大模型真是趋势，今后（起码是近些年）打比赛，应该应用尽用大模型才能拿到一个比较满意的名次吧。继续努力。\n"},{"title":"刷题记录","url":"/2024/08/02/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"\n\n\n方法\n题目\n链接\n\n\n\n栈\n最长有效括号\nhttps://leetcode.cn/problems/longest-valid-parentheses/description/\n\n\n哈希\n字母异位词分组\nhttps://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&amp;envId=top-100-liked\n\n\n哈希\n最长连续序列\nhttps://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&amp;envId=top-100-liked\n\n\n枚举\n直角三角形\nhttps://leetcode.cn/problems/right-triangles/description/?envType=daily-question&amp;envId=2024-08-02\n\n\n枚举\n到达第K级台阶的方案数\nhttps://leetcode.cn/problems/find-number-of-ways-to-reach-the-k-th-stair/description/?envType=daily-question&amp;envId=2024-08-20\n\n\n位运算\n数组最后一个元素的最小值\nhttps://leetcode.cn/problems/minimum-array-end/description/?envType=daily-question&amp;envId=2024-08-22\n\n\n动态规划\n最长有效括号\nhttps://leetcode.cn/problems/longest-valid-parentheses/description/\n\n\n直角三角形枚举| 0 | 1 | 1 | 0 | 1 || 0 | 1 | 0 | 0 | 1 || 1 | 1 | a | 0 | 1 || 0 | 1 | 1 | 0 | 1 || 0 | 1 | 1 | 0 | 1 |以当前点为直角点，把所有 1 为执直角点能组成直角三角形个数相加即为答案。 a 为例， a 的左边有两个 1 ，上面只有一个 1 ，那么左上方的直角三角形有 1 × 2 &#x3D; 2 个，右上的直角三角形有 1 个，以此类推，可得 a 为直角点能组成 2 + 1 + 2 + 4 &#x3D; 9 个，也就是 a所在行1的个数（3） × a所在列1的个数（3）。\nclass Solution:    def numberOfRightTriangles(self, grid: List[List[int]]) -&gt; int:        n = len(grid)        m = len(grid[0])        n1 = [0 for i in range(n)]        m1 = [0 for i in range(m)]        result = 0        for i in range(n):            for j in range(m):                n1[i] += grid[i][j]                m1[j] += grid[i][j]        for i in range(n):            for j in range(m):                if grid[i][j] != 1:                    continue                else:                    result += (n1[i] - 1) * (m1[j] - 1)        return result\n\n\n\n到达第K级台阶的方案数枚举令向下走为操作 1 ，向上走为操作 2 。如果要向上走 n 次，那么最高可以达到 2^n - 1 台阶，即进行了 0 次操作 1 ；最低可以到达 2^n - 1 - (n + 1) 台阶，也就是进行了 n + 1 次操作 1 （n - 1个间隔和前 1 后 1 ）。 因为一开始是从第 1 阶台阶开始，所以进行 n 次操作 2 可以到达的台阶的范围是 [2^n - n - 1, 2^n] 。题目要求我们最终到达第 k 个台阶，那么我们只需要让 k 落在  [2^n - n - 1, 2^n] 这个区间里，就意味着进行 n 次操作 2 可以上到第 k 个台阶。此时进行操作 1 的次数为 2^n - k ，因此进行 n 次操作 2 可以有从 n + 1 个间隔中选出 2^n - k 个间隔的数量的方案，即 n + 1 与 2^n - k 的组合数个方案。\nclass Solution:    def waysToReachStair(self, k: int) -&gt; int:        n, result = 0, 0        pow2 = 1  # 2的0次方        while 1:            if pow2 - n - 1 &lt;= k &lt;= pow2:                result += comb(n + 1, pow2 - k)            elif k &lt; pow2 - n - 1:                break            n += 1            pow2 *= 2        return result\n\n\n\n数组最后一个元素的最小值题目要求数组 nums 中所有元素的按位 AND 运算结果为 x ，也就是说 nums 中的所有元素的二进制数中，和 x 的二进制数中 1 的位置相同的位置都是 1 ，例如 x 是 0b01001110 ，那么 nums 中的所有元素一定是 0by1yy111y ，这里的 y 代表 0 或 1 。我们只需要在 x 的 0 的位置填 1 。如果 0 的位置不够就加前导 0 。\nclass Solution:    def minEnd(self, n: int, x: int) -&gt; int:        if n == 1:            return x                bitCount = n.bit_length() + x.bit_count()        result, i = x, 0        n -= 1        for j in range(bitCount):            if ((result &gt;&gt; j) &amp; 1) == 0:                 if ((n &gt;&gt; i) &amp; 1) != 0:                    result |= (1 &lt;&lt; j)                i += 1        return result\nclass Solution:    def minEnd(self, n: int, x: int) -&gt; int:        n -= 1  # 先把 n 减一，这样下面讨论的 n 就是原来的 n-1        i = j = 0        while n &gt;&gt; j:            # x 的第 i 个比特值是 0，即「空位」            if (x &gt;&gt; i &amp; 1) == 0:                # 空位填入 n 的第 j 个比特值                x |= (n &gt;&gt; j &amp; 1) &lt;&lt; i                j += 1            i += 1        return x\nclass Solution:    def minEnd(self, n: int, x: int) -&gt; int:        n -= 1  # 先把 n 减一，这样下面讨论的 n 就是原来的 n-1        j = 0        t = ~x        while n &gt;&gt; j:            lb = t &amp; -t            x |= (n &gt;&gt; j &amp; 1) * lb            j += 1            t ^= lb        return x\n\n\n\n\n最长有效括号栈先在栈底放置 0 的左边的下标 -1 ，表示 0 的左边已经被分割成一个字串接下来遇到 ( 就将下标入栈，遇到 ) 则先出栈，用当前下标减去当前栈顶元素得到一个长度值，将该长度值与原来长度值比较取较大者，若出栈后栈空，则表示遇到了多余的 ) 打破连续状态，那么就把当前下标入栈，继续下一轮循环。\nclass Solution:    def longestValidParentheses(self, s: str) -&gt; int:        stack = [-1]        result = 0        tmp = 0        n = len(s)        for i in range(n):            if s[i] == &#x27;(&#x27;:                stack.append(i)            elif s[i] == &#x27;)&#x27;:                stack.pop(-1)                if stack:                    tmp = i - stack[-1]                    result = max(result, tmp)                else:                    stack.append(i)        return result\n\n\n左右遍历先左遍历再右遍历左右括号的个数，若个数相等，那么就是有效括号，更新长度值。左遍历时，如果遇到 ……(……))…… 即右括号个数大于左括号个数的情况，说明连续状态被打破，此时重置左右括号个数为0；不用担心 ……((……)…… 的情况，因为后面左括号个数会大于右括号个数，长度值不更新。同理，右遍历则需要注意 ……((……)…… 即左括号个数大于右括号个数的情况。\nclass Solution:    def longestValidParentheses(self, s: str) -&gt; int:        result = 0        left = 0        right = 0        n = len(s)        for i in range(n):            if s[i] == &#x27;(&#x27;:                left += 1            elif s[i] == &#x27;)&#x27;:                right += 1            if left == right:                result = max(result, left + right)            elif right &gt; left:                left = 0                right = 0        left = 0        right = 0        for i in range(n - 1, -1, -1):            if s[i] == &#x27;(&#x27;:                left += 1            elif s[i] == &#x27;)&#x27;:                right += 1            if left == right:                result = max(result, left + right)            elif left &gt; right:                left = 0                right = 0        return result\n\n\n动态规划用一个dp数组表示以下标 i 结尾的最长有效括号长度值，也就是最终答案为 max(dp) 。初始化为 0 ，显然 ( 的dp值为 0 。求状态转移方程：\n\ns[i] &#x3D;&#x3D; ‘)’ and s[i - 1] &#x3D;&#x3D; ‘(‘ ，即 ……()…… ，可以推出 dp[i] = dp[i - 2] + 2 ，因为 () 是一个有效子串，把前面的有效子串长度加上 () 长度2\ns[i] &#x3D;&#x3D; ‘)’ and s[i - 1] &#x3D;&#x3D; ‘)’ ，即 ……))…… ，也就是 dp[i - 1] !&#x3D; 0 ，那么意味着 s[i] 这个 ) 只能从 i - 2 前面寻找 ( 。 i - dp[i - 1] 表示和 i - 1 匹配的子串的起始位置，如果 s[i - dp[i - 1] - 1] 是 ( ，则找到了和 s[i] 匹配的左括号，这时候 dp[i] 的值应该是 2 ( s[i] 这对括号的长度) + dp[i - 1] (被包裹的子串长度) + dp[i - dp[i-1] - 2] (之前的子串) ，即推出 dp[i] = 2 + dp[i - 1] + dp[i - dp[i-1] - 2]-1 问题：\n遇到 ())…… 的情况，python中的 -1 表示最后一位，而此时第二个 ) 应该在 s[0] 的左边寻找 ( ，不应该去末尾寻找，所以应该加一个限制条件 i - dp[i - 1] - 1 &gt;&#x3D; 0\n对于 (())…… 的情况，一开始初始化dp数组为全 0 ，所以 dp[i - dp[i-1] - 2] &#x3D; dp[-1] &#x3D; 0 ，无影响\n\nclass Solution:    def longestValidParentheses(self, s: str) -&gt; int:        n = len(s)        if n == 0:            return 0        dp = [0 for i in range(n)]        for i in range(n):            if s[i] == &#x27;)&#x27; and i - dp[i - 1] - 1 &gt;= 0  and s[i - dp[i - 1] - 1] == &#x27;(&#x27;:                dp[i] = 2 + dp[i - 1] + dp[i - dp[i-1] - 2]        return max(dp)\n\n\n字母异位词分组哈希互为异位词的单词拥有相同的字母，只是顺序不一样，因此将字母排序后所有异位词都相同，所以可以把排序后的字母作为哈希表的键。\nclass Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        if len(strs) &lt;= 1:            return [strs]        mp = collections.defaultdict(list)        for c in strs:            mp[&#x27;&#x27;.join(sorted(c))].append(c)        return list(mp.values())\n\n\n最长连续序列哈希这里用了一个比较巧妙的方法：把所给的数组当作哈希表。对于所给数组里的数 num ，如果 num - 1 不在数组里，说明 num 是序列的起始，接下来就可以看 num + 1 是否存在，直到 num + 1 不在数组里面，意味着序列结束。\nclass Solution:    def longestConsecutive(self, nums: List[int]) -&gt; int:        n = len(nums)        if n == 0:            return 0        if n == 1:            return 1        count = 0        mp = set(nums)        for i in mp:            if i - 1 not in mp:                tmp = 1                while i + 1 in mp:                    i += 1                    tmp += 1                count = max(count, tmp)        return count\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}]